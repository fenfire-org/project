
http://iswc2005.semanticweb.org/

April 30, 2005  	Research Track paper submissions due

Title:
Topics: (select applicable) user interfaces?
Keywords:
Abstract:




An architecture for RDF editor
==============================



Introduction
------------


The Fenfire project has been working on an item-based information
management environment for XXX years, first as an implementation of
Ted Nelson's ZigZag and later based on the W3C standards for the
Semantic Web. The environment has not reached a useful state yet,
largely because of the unconventional software requirements of such a
system, but along the Semantic Web standards a subgoal of an RDF
editor has emerged. To bring closer our gap to the Semantic Web
community, we would like to report on our research to the extent it
concerns an architecture for RDF editor.

- motivation
- previous concepts



Previous work
-------------


SemNet has focus+context view. BrownSauce has a navigational view for
RDF. Haystack has views for properties. Gnowsis is building a Semantic
Desktop. 



General architecture
--------------------


As a set of RDF triples is conventionally imaged as a graph of
labelled nodes, we want the editor to let the user browse this graph,
make updates to it and create new triples. However, as the amount of
triples can be high, RDF is a very general model, and the level of
information can be too low for the user, such a user interface is not
straight-forward. 

We propose the use of various *views* to represent the graph model to the
user, in connection with several *controllers* that allow the user to
make changes to the underlying model in ways that reflect the view the
user sees. This is not unlike the widely used Model-View-Controller
separation of user interfaces but we use the RDF graph as the sole
model, instead of several, application specific ones.

Architecturally important is that the view the user sees and the
controller to it are actually built from several views that separate
concerns and permit combination of the views to match different kinds
of user need. Larger views for RDF constructs are built from smaller
views of RDF primitives. The views actually interface with other views
through view type interfaces, so we can have several implementations
for each type.


Representation views

The smallest view in the architecture under discussion is a
*representation view*. These views are able to give a graphical
representation of a node that can then be used as a part of a view
that shows some larger construct in the graph.

The most elementary instance of a representation view in our
implementation is called TextReprView. It gives a textual
representation, most simply the URI of the node in question. We also
keep a list of *text properties* and if there is a literal value on
any of these properties, we use one of those instead of the URI. To
benefit from language information associated with literals, we prefer
a literal that matches the user's locale to those that don't have
language information or even have another language declared. If the
node in question is a literal itself, we indicate that by putting the
literal value in quotes, ie. "This is not John, this is the word 'John'."

Another example of a representation view would be one that in addition
to the textual representation view shows any ``foaf:nick`` property of
the node in parentheses. The applicability of this is highly specific
to the task of viewing FOAF information about people who the user
might better know by nickname than by full name. However, the choice
of the additional property could be user-configurable thus making the
view applicable for any parenthetical information.

Our implementation also contains a graphical representation view for
areas of PDF documents. It works by interpreting properties in a
vocabulary for decribing such areas and displaying the associated
image data.


Property views

The next smallest views after the representation views are the
property views. These views give a user-interface element for the triples
of a given node that have the same property as their predicate. 

Our implementation of a general property view employs four columns to
communicate the property, its direction and its value to the user. The
first column gives the inverse property, the second column gives the value
of the inverse property, the third column gives the positive property
and the fourth column gives the value of the positive property. If
either the inverse or positive property doesn't have a value, the
respective columns are left empty. This arrangement can be argued
to be wasteful, but we hope to provide the user with a feeling of
spatiality and navigational directions. If there is more than one
value on the property, the view adds enough rows for the rest of the values.

An important property view in our implementation is the *literal
property view*. As a literal can only take the position of an object
in a triple and is not important navigationally, we provide a
full-width text area for the literal. It can be important to be able
to view a long literal, so the text area has multiple lines if
necessary. 

One more viewlet implemented is the container viewlet. Instead of
using a representation view to show the container, it goes through the
container to the elements and shows them as a list. To the reverse
direction, for any of the elements it shows the node that has the
container as a property.


Spatial views

The representation and property views are points in their spatial
nature. With this we mean that they don't provide visual connections
between views and they show a single location in the graph. For a
representation view this is clear, and for a property view we ask the
reader to take into consideration that a property view shows only a
single property at a time. A spatial view in this architecture is a lot
like a window that can be scrolled and that gives an arrangement of
related information.

One of the spatial views in our implementation is the property list
view that builds on the property views of the previous section. It
provides a simple arrangement of the neighbourhood of a node by
putting a representation view of the node to the top as a heading and
below that a list of property views for each property of the node. The
user can scroll the list if there are more properties than fit on the
screen at a time.

Another spatial view is the canvas view. It shows a two-dimensional
space around a node by interpreting an RDF vocabulary of canvases and
items on it, where each item has x and y coordinates as
properties. Each item on the canvas is displayed using a
representation view, which allows textual items, regions of PDF
documents etc. to be arranged.

We have also implemented a spatial view for the PDF documents
themselves. The user can read the document and scroll in it. Any
regions that some node represents are shown as hollow rectangles on
the document. This allows the user to discover and browse links,
comments or nodes about the document.


Structure views

We have tried to make Fenfire useful as an RDF editor with the
previous free view types. However, we want to discuss one more view
type that is natural to any kind of structural data and an RDF graph
in particular. Unfortunately the intellectual property status of the
view type is unclear because of granted patents on it, and thus we
don't have a published implementation of these views. The type of view
in question is a view that shows an item, and related items around
it. We call this kind of a view a structural view.

The free implementation we would like to publish along our software
shows for a node a spatial view of it. In a circle around are
property values of the node in smaller spatial views. Depending on
space on the screen, the performance of the computer and nature of the
RDF graph in question, the number of shown properties can be limited
and the user can rotate to see other properties, or we can show more
properties, even properties of properties recursively. 

If a spatial view is like a window, a structure view is like
connections between related items, *between different windows*. We
think it is useful in providing the user with a better view of
relations in the surroundings of the current focus. It also provides
visual connections and integration between several spatial views, even
those of different implementation.


